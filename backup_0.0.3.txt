import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { IFCLoader } from 'web-ifc-three';

const container = document.getElementById("viewer");
const loading = document.getElementById("loading");
const loadingText = document.getElementById("loadingText");
const progressBar = document.getElementById("progressBar");
const info = document.getElementById("info");
const stats = document.getElementById("stats");

console.log('üöÄ Three.js carregado, vers√£o:', THREE.REVISION);

// Cena
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1f2e);

// C√¢mera
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(20, 20, 20);

// Renderer com m√°xima qualidade
const renderer = new THREE.WebGLRenderer({ 
    antialias: true, 
    alpha: true,
    powerPreference: "high-performance"
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

// Controles
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 1;
controls.maxDistance = 500;

// Grid e Eixos
const gridHelper = new THREE.GridHelper(100, 100, 0x4488ff, 0x223344);
scene.add(gridHelper);
const axesHelper = new THREE.AxesHelper(10);
scene.add(axesHelper);

// Ilumina√ß√£o melhorada
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.7));

const light1 = new THREE.DirectionalLight(0xffffff, 1.0);
light1.position.set(50, 80, 50);
light1.castShadow = true;
light1.shadow.mapSize.width = 4096;
light1.shadow.mapSize.height = 4096;
light1.shadow.camera.near = 0.5;
light1.shadow.camera.far = 500;
light1.shadow.camera.left = -100;
light1.shadow.camera.right = 100;
light1.shadow.camera.top = 100;
light1.shadow.camera.bottom = -100;
light1.shadow.bias = -0.00001;
light1.shadow.radius = 2;
scene.add(light1);

const light2 = new THREE.DirectionalLight(0xffffff, 0.4);
light2.position.set(-50, 40, -50);
scene.add(light2);

const light3 = new THREE.DirectionalLight(0xffeedd, 0.3);
light3.position.set(0, 50, -100);
scene.add(light3);

const light4 = new THREE.DirectionalLight(0x8899ff, 0.2);
light4.position.set(0, -20, 0);
scene.add(light4);

// IFC Loader
const ifcLoader = new IFCLoader();
let ifcAPI = null;

try {
    if (ifcLoader.ifcManager && ifcLoader.ifcManager.setWasmPath) {
        ifcLoader.ifcManager.setWasmPath('https://unpkg.com/web-ifc@0.0.53/');
        
        if (ifcLoader.ifcManager.setupThreeMeshBVH) {
            ifcLoader.ifcManager.setupThreeMeshBVH();
        }
        
        // Guarda refer√™ncia da API IFC para extrair propriedades
        ifcAPI = ifcLoader.ifcManager;
        
        console.log('‚úÖ WASM path configurado');
    } else {
        console.log('‚ö†Ô∏è ifcManager n√£o dispon√≠vel, usando fallback');
    }
} catch (e) {
    console.log('‚ö†Ô∏è Erro ao configurar WASM:', e.message);
}

let loadedModel = null;
let edgesGroup = new THREE.Group();
let currentModelID = null;

// Cubo demo
let demoCube = new THREE.Mesh(
    new THREE.BoxGeometry(5, 5, 5),
    new THREE.MeshStandardMaterial({ color: 0x0066ff, metalness: 0.3, roughness: 0.6 })
);
demoCube.position.y = 2.5;
demoCube.castShadow = true;
demoCube.receiveShadow = true;
scene.add(demoCube);

const edges = new THREE.EdgesGeometry(demoCube.geometry);
demoCube.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff })));

console.log('üöÄ BIM Viewer PRO pronto!');
info.classList.add('show');

// Anima√ß√£o
function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
}
animate();

// Resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Fun√ß√£o centralizar
function fitCameraToModel(model) {
    const box = new THREE.Box3().setFromObject(model);
    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    
    gridHelper.position.y = box.min.y - 0.1;
    
    const maxDim = Math.max(size.x, size.y, size.z);
    const fov = camera.fov * (Math.PI / 180);
    let cameraZ = Math.abs(maxDim / Math.tan(fov / 2)) * 2.5;
    
    camera.position.set(
        center.x + cameraZ * 0.5,
        center.y + cameraZ * 0.5,
        center.z + cameraZ * 0.5
    );
    
    controls.target.copy(center);
    controls.update();
    
    console.log('üì¶ Dimens√µes:', size, 'üìç Centro:', center);
}

// Fun√ß√£o para adicionar bordas
function addEdgesToMesh(mesh) {
    if (!mesh.geometry) return;
    
    try {
        const edges = new THREE.EdgesGeometry(mesh.geometry, 15);
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x000000, 
            opacity: 0.3, 
            transparent: true,
            linewidth: 1 
        });
        const lineSegments = new THREE.LineSegments(edges, lineMaterial);
        
        lineSegments.position.copy(mesh.position);
        lineSegments.rotation.copy(mesh.rotation);
        lineSegments.scale.copy(mesh.scale);
        
        edgesGroup.add(lineSegments);
    } catch (e) {
        console.warn('‚ö†Ô∏è Erro ao adicionar bordas');
    }
}

// Fun√ß√£o para extrair propriedades IFC de um elemento
async function getIFCProperties(modelID, expressID) {
    if (!ifcAPI || !modelID) return null;
    
    try {
        // Tenta obter propriedades do elemento
        const props = await ifcAPI.getItemProperties(modelID, expressID, true);
        return props;
    } catch (e) {
        return null;
    }
}

// Fun√ß√£o para extrair tipo IFC do elemento
async function getIFCType(modelID, expressID) {
    if (!ifcAPI || !modelID) return null;
    
    try {
        const type = await ifcAPI.getTypeProperties(modelID, expressID, true);
        return type;
    } catch (e) {
        return null;
    }
}

// Mapeamento de tipos IFC para materiais padr√£o
const ifcTypeMaterialDefaults = {
    // Paredes
    'IFCWALL': { color: 0xe0e0e0, metalness: 0.0, roughness: 0.8 },
    'IFCWALLSTANDARDCASE': { color: 0xd4d4d4, metalness: 0.0, roughness: 0.8 },
    
    // Pisos/Lajes
    'IFCSLAB': { color: 0xcccccc, metalness: 0.1, roughness: 0.6 },
    'IFCSLABSTANDARDCASE': { color: 0xc0c0c0, metalness: 0.1, roughness: 0.6 },
    
    // Portas e Janelas
    'IFCDOOR': { color: 0x8b4513, metalness: 0.2, roughness: 0.7 },
    'IFCWINDOW': { color: 0x87ceeb, metalness: 0.3, roughness: 0.2, transparent: true, opacity: 0.5 },
    
    // M√≥veis
    'IFCFURNISHINGELEMENT': { color: 0xa0522d, metalness: 0.2, roughness: 0.6 },
    'IFCFURNITURE': { color: 0xa0522d, metalness: 0.2, roughness: 0.6 },
    
    // Estruturas
    'IFCBEAM': { color: 0x808080, metalness: 0.3, roughness: 0.5 },
    'IFCCOLUMN': { color: 0x696969, metalness: 0.3, roughness: 0.5 },
    
    // Cobertura
    'IFCROOF': { color: 0x8b0000, metalness: 0.1, roughness: 0.8 },
    
    // Escadas
    'IFCSTAIR': { color: 0xb8b8b8, metalness: 0.2, roughness: 0.7 },
    'IFCRAILING': { color: 0x4682b4, metalness: 0.6, roughness: 0.3 },
    
    // Equipamentos
    'IFCBUILDINGELEMENTPROXY': { color: 0xdcdcdc, metalness: 0.1, roughness: 0.7 },
    
    // Default
    'DEFAULT': { color: 0xcccccc, metalness: 0.1, roughness: 0.7 }
};

// Fun√ß√£o MELHORADA para processar com propriedades IFC
async function processAllMeshesWithIFC(object, modelID, depth = 0) {
    const indent = '  '.repeat(depth);
    
    // Processa se for Mesh
    if (object.isMesh) {
        const expressID = object.userData?.expressID || object.expressID;
        
        console.log(`${indent}üîç Mesh: ${object.name || 'sem nome'} | ExpressID: ${expressID}`);
        
        // Tenta obter propriedades IFC
        let ifcProps = null;
        let ifcType = null;
        let ifcTypeName = 'UNKNOWN';
        
        if (expressID && modelID) {
            ifcProps = await getIFCProperties(modelID, expressID);
            ifcType = await getIFCType(modelID, expressID);
            
            if (ifcType && ifcType.type) {
                ifcTypeName = ifcType.type;
                console.log(`${indent}  üìã Tipo IFC: ${ifcTypeName}`);
            }
            
            if (ifcProps) {
                console.log(`${indent}  üìÑ Propriedades:`, ifcProps);
            }
        }
        
        if (object.material) {
            const materials = Array.isArray(object.material) ? object.material : [object.material];
            
            const newMaterials = materials.map((mat, idx) => {
                // Extrai cor original
                let materialColor = new THREE.Color();
                
                if (mat.color && mat.color.getHex() !== 0xffffff && mat.color.getHex() !== 0xcccccc) {
                    // Se j√° tem cor v√°lida, usa
                    materialColor.copy(mat.color);
                    console.log(`${indent}  ‚úÖ Cor existente: #${materialColor.getHexString()}`);
                } else {
                    // Usa cor padr√£o baseada no tipo IFC
                    const defaultMat = ifcTypeMaterialDefaults[ifcTypeName] || ifcTypeMaterialDefaults['DEFAULT'];
                    materialColor.setHex(defaultMat.color);
                    console.log(`${indent}  üé® Aplicando cor padr√£o para ${ifcTypeName}: #${materialColor.getHexString()}`);
                }
                
                // Obt√©m propriedades padr√£o do tipo
                const defaultMat = ifcTypeMaterialDefaults[ifcTypeName] || ifcTypeMaterialDefaults['DEFAULT'];
                
                // Se j√° √© Standard, atualiza
                if (mat.type === 'MeshStandardMaterial') {
                    mat.color.copy(materialColor);
                    mat.metalness = defaultMat.metalness;
                    mat.roughness = defaultMat.roughness;
                    if (defaultMat.transparent) {
                        mat.transparent = true;
                        mat.opacity = defaultMat.opacity;
                    }
                    mat.needsUpdate = true;
                    return mat;
                }
                
                // Cria novo material Standard
                const newMat = new THREE.MeshStandardMaterial({
                    color: materialColor,
                    metalness: defaultMat.metalness,
                    roughness: defaultMat.roughness,
                    transparent: defaultMat.transparent || mat.transparent || false,
                    opacity: defaultMat.opacity || mat.opacity || 1.0,
                    side: THREE.DoubleSide,
                    flatShading: false,
                    vertexColors: false,
                    envMapIntensity: 0.5
                });
                
                // Preserva propriedades especiais do material original
                if (mat.emissive && mat.emissive.getHex() !== 0x000000) {
                    newMat.emissive.copy(mat.emissive);
                    newMat.emissiveIntensity = mat.emissiveIntensity || 0;
                }
                
                // Preserva texturas
                if (mat.map) {
                    newMat.map = mat.map;
                    newMat.map.colorSpace = THREE.SRGBColorSpace;
                    newMat.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                }
                if (mat.normalMap) newMat.normalMap = mat.normalMap;
                if (mat.roughnessMap) newMat.roughnessMap = mat.roughnessMap;
                if (mat.metalnessMap) newMat.metalnessMap = mat.metalnessMap;
                if (mat.aoMap) {
                    newMat.aoMap = mat.aoMap;
                    newMat.aoMapIntensity = 1.0;
                }
                if (mat.bumpMap) {
                    newMat.bumpMap = mat.bumpMap;
                    newMat.bumpScale = mat.bumpScale || 1;
                }
                
                newMat.needsUpdate = true;
                
                console.log(`${indent}  ‚úÖ Material final: #${newMat.color.getHexString()}`);
                
                return newMat;
            });
            
            object.material = Array.isArray(object.material) ? newMaterials : newMaterials[0];
            
            // Adiciona bordas
            addEdgesToMesh(object);
            
            // Atualiza geometria
            if (object.geometry) {
                object.geometry.computeVertexNormals();
            }
        }
        
        // Ativa sombras
        object.castShadow = true;
        object.receiveShadow = true;
    }
    
    // Processa filhos recursivamente
    if (object.children && object.children.length > 0) {
        console.log(`${indent}üìÅ Grupo: ${object.name || 'sem nome'} (${object.children.length} filhos)`);
        for (const child of object.children) {
            await processAllMeshesWithIFC(child, modelID, depth + 1);
        }
    }
}

// Carregar IFC
document.getElementById("fileInput").addEventListener("change", async (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (loadedModel) {
        scene.remove(loadedModel);
        scene.remove(edgesGroup);
        loadedModel = null;
        edgesGroup = new THREE.Group();
        currentModelID = null;
    }

    if (demoCube) {
        scene.remove(demoCube);
        demoCube = null;
    }

    loading.classList.add('show');
    info.classList.remove('show');
    stats.classList.remove('show');
    progressBar.style.width = '0%';

    try {
        const url = URL.createObjectURL(file);
        console.log('üîÑ Carregando:', file.name, '| Tamanho:', (file.size / 1024).toFixed(2), 'KB');
        
        ifcLoader.load(
            url,
            async (ifcModel) => {
                loadedModel = ifcModel;
                
                // Obt√©m ID do modelo IFC
                currentModelID = ifcModel.modelID || 0;
                
                console.log('üé® ===== PROCESSANDO COM PROPRIEDADES IFC =====');
                console.log('üÜî Model ID:', currentModelID);
                
                // Processa com extra√ß√£o de propriedades IFC
                await processAllMeshesWithIFC(ifcModel, currentModelID, 0);
                
                // Adiciona √† cena
                scene.add(ifcModel);
                scene.add(edgesGroup);
                
                // Estat√≠sticas
                let meshCount = 0;
                let groupCount = 0;
                const finalColors = new Map();
                const ifcTypes = new Map();
                
                ifcModel.traverse((child) => {
                    if (child.isMesh) {
                        meshCount++;
                        
                        // Coleta tipos IFC
                        const expressID = child.userData?.expressID || child.expressID;
                        if (expressID) {
                            const typeName = child.userData?.ifcType || 'UNKNOWN';
                            ifcTypes.set(typeName, (ifcTypes.get(typeName) || 0) + 1);
                        }
                        
                        if (child.material) {
                            const mats = Array.isArray(child.material) ? child.material : [child.material];
                            mats.forEach(mat => {
                                if (mat.color) {
                                    const hex = '#' + mat.color.getHexString();
                                    finalColors.set(hex, (finalColors.get(hex) || 0) + 1);
                                }
                            });
                        }
                    } else if (child.isGroup || child.isObject3D) {
                        groupCount++;
                    }
                });
                
                console.log('üé® ===== RESULTADO FINAL =====');
                console.log(`üì¶ Meshes: ${meshCount}`);
                console.log(`üìÅ Grupos: ${groupCount}`);
                console.log(`üé® Cores √∫nicas: ${finalColors.size}`);
                console.log(`üìê Bordas: ${edgesGroup.children.length}`);
                
                console.log('\nüèóÔ∏è Tipos IFC encontrados:');
                ifcTypes.forEach((count, type) => {
                    console.log(`  ${type}: ${count}x`);
                });
                
                console.log('\nüé® Distribui√ß√£o de cores:');
                finalColors.forEach((count, color) => {
                    console.log(`  ${color}: ${count}x`);
                });
                
                console.log('================================');
                
                fitCameraToModel(ifcModel);
                
                document.getElementById('modelName').textContent = file.name;
                document.getElementById('meshCount').textContent = `${meshCount} objetos (${finalColors.size} cores)`;
                
                loading.classList.remove('show');
                info.classList.add('show');
                stats.classList.add('show');
                
                console.log('üéâ Modelo carregado com propriedades IFC!');
                URL.revokeObjectURL(url);
            },
            (progress) => {
                if (progress.total > 0) {
                    const percent = (progress.loaded / progress.total) * 100;
                    progressBar.style.width = percent + '%';
                    loadingText.textContent = `Carregando: ${percent.toFixed(0)}%`;
                }
            },
            (error) => {
                console.error('‚ùå Erro:', error);
                loading.classList.remove('show');
                alert('Erro ao carregar IFC: ' + error.message);
                URL.revokeObjectURL(url);
            }
        );
    } catch (error) {
        console.error('‚ùå Erro cr√≠tico:', error);
        loading.classList.remove('show');
        alert('Erro: ' + error.message);
    }
});